ecmascript 6


1.一切都是对象
------------------------------------------------
一切引用类型都是对象。

2.函数和对象的关系
------------------------------------------------
对象都是由函数创建的【会有使用语法糖的情况】，函数本身也是对象。

3.prototype原型
------------------------------------------------
函数包含的默认属性prototype，prototype中包含默认属性constructor，constructor指向函数本身。

4.隐式原型
------------------------------------------------
对象默认包含__proto__属性，__proto__指向创建该对象的函数的prototype。

5.instanceof
------------------------------------------------
A对象的__proto__跟B函数的prototype如果指向同一个节点，说明他们是同一个对象。

6.继承
------------------------------------------------
原型链：访问对象属性的时候，先在对象的基础属性里边找，如果没找到，再到__proto__中找。

7.原型的灵活性
------------------------------------------------
对函数、属性：可扩展，可重写

8.简述【执行上下文】上
------------------------------------------------
执行上下文就是代码在执行之前做的准备工作（赋值或者用undefined占坑）
变量作用域在定义的时候就确定了
全局作用域：变量、函数表达式 undefined占坑；this赋值；函数声明赋值。

9.简述【执行上下文】下
------------------------------------------------
执行上下文就是代码在执行之前做的准备工作（赋值或者用undefined占坑）
变量作用域在定义的时候就确定了
函数作用域：变量赋值、arguments赋值、自由变量的取值作用域赋值

10.this
------------------------------------------------
构造函数
1.new 将要创建的对象本身
2.直接调用 window

对象的属性
1.作为对象的属性直接被调用时，this指对象本身
2.不直接调用时 window

apply或者call
1.标识传入的对象

全局或者调用普通函数
1.永远是window

11.执行上下文栈
------------------------------------------------
处于活动状态的上下文环境永远只有一个
运行到某个上下文环境时，都会有一个赋值过程

12.简介作用域
------------------------------------------------
作用：隔离变量
只有【全局、函数】两个作用域
没有块级用作用域 {} if/for

13.【作用域】和【上下文环境】
------------------------------------------------
作用域在函数定义时确定，作用域中变量的值在执行过程中确定
要查找一个作用域下某个变量的值，需要找到作用域对应的上下文环境，再在其中寻找变量的值

14.从【自由变量】到【作用域链】
------------------------------------------------
自由变量：函数作用域内出现的【不属于函数内的参数】和【函数内定义的变量】的变量
自由变量取值需要到创建当前函数的作用域中取值

15.闭包
------------------------------------------------
定义：函数作为返回值、函数作为参数